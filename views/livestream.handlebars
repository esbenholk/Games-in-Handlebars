<!DOCTYPE html>
<html lang="en">
	<head>
		<title>HOUSE OF KILLING</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="archivestyle.css">
		<style>
            #video{
                display: none;
            }
            #chat{

                position: fixed;
                bottom: 0;
                right: 0;
            }
		</style>
	</head>
	<body>
        <!-- <video id="video" class="video" autoplay></video> -->
		<!-- <div id="blocker">

			<div id="instructions">

				enjoy yourself(ie)â„¢<br/>

				<span class="play">Click to play</span>
				<br /><br />
				Move: WASD<br/>
				Jump: SPACE<br/>
				Look: MOUSE<br/>
                escape: ESC
			</div>
		</div> -->
        <div id="chat">

            <ul id="messages"></ul>
                <form action="">
                  <input id="m" autocomplete="off" /><button>Send</button>
                </form>
        </div>
    <!-- <video id="localVideo" class="video1" playsinline muted></video> -->
    <button id="btn-open-room">Open Room</button>
    <button id="btn-join-room">Join Room</button><hr>



<script src="/socket.io/socket.io.js"></script>
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
<script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
<script src="https://rtcmulticonnection.herokuapp.com/dist/RTCMultiConnection.min.js"></script>
<script src="https://rtcmulticonnection.herokuapp.com/socket.io/socket.io.js"></script>
<script type="module">
var connection = new RTCMultiConnection();
connection.socketURL = 'localhost:8080/';
connection.session = {
    audio: true,
    video: true
};

connection.sdpConstraints.mandatory = {
    OfferToReceiveAudio: true,
    OfferToReceiveVideo: true
};

connection.onstream = function(event) {
    document.body.appendChild( event.mediaElement );
};
var predefinedRoomId = 'YOUR_Name';

document.getElementById('btn-open-room').onclick = function() {
    this.disabled = true;
    connection.open( predefinedRoomId );
};

document.getElementById('btn-join-room').onclick = function() {
    this.disabled = true;
    connection.join( predefinedRoomId );
};



$(function () {
    var socket = io();
    $('form').submit(function(e) {
      e.preventDefault(); // prevents page reloading
      socket.emit('chatmessage', $('#m').val());
      $('#m').val('');
      return false;
    });
    socket.on('chatmessage', function(msg){
      $('#messages').append($('<li>').text(msg));
    });
    socket.on("livestream", function(stream){
        console.log("stream recieved frontend", stream);
        // var video2 = document.getElementById("video2");
        // video2.srcObject = stream;

    })
    var video = document.getElementsByClassName("video1");
    let webcam = true;
    // Get access to the camera!
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      // Not adding `{ audio: true }` since we only want video now
      navigator.mediaDevices.getUserMedia({ video: true }).then(function(stream) {
        //video.src = window.URL.createObjectURL(stream);
        for (var i = 0; i < video.length; i++) {
          video[i].srcObject = stream;
          video[i].play();
          socket.emit('livestream', stream);
        }
      });
    } else {
      video[i].src = "https://www.youtube.com/watch?v=f7weYZUUv90";
    }
  });




// import * as THREE from '/three/build/three.module.js';
// import { PointerLockControls } from '/three/examples/jsm/controls/PointerLockControls.js';
//
//
// 		var camera, scene, renderer, controls, group;
//
// 		var objects = [];
// 		let movingtext = [];
//
// 		var raycaster;
//
// 		var moveForward = false;
// 		var moveBackward = false;
// 		var moveLeft = false;
// 		var moveRight = false;
// 		var canJump = false;
//
// 		var prevTime = performance.now();
// 		var velocity = new THREE.Vector3();
// 		var direction = new THREE.Vector3();
// 		var vertex = new THREE.Vector3();
// 		var color = new THREE.Color();
//
//         let boxes=[];
// 		init();
// 		animate();
//
//         function init() {
//           //set up textureloader for url texture placement
//           const textureLoader = new THREE.TextureLoader();
//           textureLoader.crossOrigin = "Anonymous";
//           camera = new THREE.PerspectiveCamera(
//               75,
//               window.innerWidth / window.innerHeight,
//               1,
//               1000
//           );
//           camera.position.y = 40;
//           scene = new THREE.Scene();
//           scene.fog = new THREE.Fog("black", 400, 1000);
//           var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
//           light.position.set(0.5, 1, 0.75);
//           scene.add(light);
//           controls = new PointerLockControls(camera, document.body);
//
//
//           var blocker = document.getElementById( 'blocker' );
//           var instructions = document.getElementById( 'instructions' );
//
//           instructions.addEventListener( 'click', function () {
//               controls.lock();
//           }, false );
//
//           controls.addEventListener( 'lock', function () {
//
//               instructions.style.display = 'none';
//               blocker.style.display = 'none';
//
//           } );
//
//           controls.addEventListener( 'unlock', function () {
//
//               blocker.style.display = 'block';
//               instructions.style.display = '';
//
//           } );
//           scene.add(controls.getObject());
//
//           var onKeyDown = function ( event ) {
//
//               switch ( event.keyCode ) {
//
//                   case 38: // up
//                   case 87: // w
//                       moveForward = true;
//                       break;
//
//                   case 37: // left
//                   case 65: // a
//                       moveLeft = true;
//                       break;
//
//                   case 40: // down
//                   case 83: // s
//                       moveBackward = true;
//                       break;
//
//                   case 39: // right
//                   case 68: // d
//                       moveRight = true;
//                       break;
//
//                   case 32: // space
//                       if ( canJump === true ) velocity.y += 350;
//                       canJump = false;
//                       break;
//
//               }
//
//           };
//
//           var onKeyUp = function ( event ) {
//
//               switch ( event.keyCode ) {
//
//                   case 38: // up
//                   case 87: // w
//                       moveForward = false;
//                       break;
//
//                   case 37: // left
//                   case 65: // a
//                       moveLeft = false;
//                       break;
//
//                   case 40: // down
//                   case 83: // s
//                       moveBackward = false;
//                       break;
//
//                   case 39: // right
//                   case 68: // d
//                       moveRight = false;
//                       break;
//
//               }
//
//           };
//
//           document.addEventListener( 'keydown', onKeyDown, false );
//           document.addEventListener( 'keyup', onKeyUp, false );
//
//           var video = document.getElementById("localVideo");
//           let texture = new THREE.VideoTexture(video);
//           texture.minFilter = THREE.NearestFilter;
//           texture.magFilter = THREE.LinearFilter;
//           texture.format = THREE.RGBFormat;
//           function createfloor() {
//               let ground = new THREE.PlaneGeometry(500, 500, 100, 100);
//               ground.rotateX(-Math.PI / 2);
//               var material = new THREE.MeshBasicMaterial({
//                   map: texture,
//                   premultiplyAlpha: true
//
//               });
//               let floor = new THREE.Mesh(ground, material);
//               scene.add(floor);
//           }
//           createfloor();
//
//           // objects
//           let boxMaterial = new THREE.MeshBasicMaterial({ map: texture });
//           var boxGeometry = new THREE.OctahedronBufferGeometry( 100, 1 );
//           // for (let i = 0; i < this.props.images.length; i++) {
//           for (let i = 0; i < 10; i++) {
//             var box = new THREE.Mesh(boxGeometry, boxMaterial);
//             box.position.x = Math.floor(Math.random() * 20 - 10) * 60;
//             box.position.y = Math.floor(Math.random() * 500) * 4;
//             box.position.z = Math.floor(Math.random() * 20 - 10) * 60;
//             boxes.push(box);
//             scene.add(box);
//           }
//           renderer = new THREE.WebGLRenderer({
//               antialias: true,
//               alpha: true
//           });
//           renderer.setPixelRatio(window.devicePixelRatio);
//           renderer.setSize(window.innerWidth, window.innerHeight);
//           document.body.appendChild(renderer.domElement);
//
//           //
//           window.addEventListener("resize", onWindowResize, false);
//         }
//
//         function onWindowResize() {
//           camera.aspect = window.innerWidth / window.innerHeight;
//           camera.updateProjectionMatrix();
//           renderer.setSize(window.innerWidth, window.innerHeight);
//         }
//
//         function animate() {
//           let canvases = document.getElementsByTagName("canvas");
//           requestAnimationFrame(animate);
//           // raycaster.ray.origin.copy(controls.getObject().position);
//           // raycaster.ray.origin.y -= 10;
//           // var intersections = raycaster.intersectObjects(objects);
//           function createControls() {
//               var time = performance.now();
//               var delta = (time - prevTime) / 1000;
//               velocity.x -= velocity.x * 10.0 * delta;
//               velocity.z -= velocity.z * 10.0 * delta;
//               velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass
//               direction.z = Number(moveForward) - Number(moveBackward);
//               direction.x = Number(moveRight) - Number(moveLeft);
//               direction.normalize(); // this ensures consistent movements in all directions
//               if (moveForward || moveBackward)
//                   velocity.z -= direction.z * 400.0 * delta;
//               if (moveLeft || moveRight)
//                   velocity.x -= direction.x * 400.0 * delta;
//
//               controls.moveRight(-velocity.x * delta);
//               controls.moveForward(-velocity.z * delta);
//               controls.getObject().position.y += velocity.y * delta; // new behavior
//               if (controls.getObject().position.y < 10) {
//                   velocity.y = 0;
//                   controls.getObject().position.y = 10;
//                   canJump = true;
//               }
//               prevTime = time;
//           }
//           createControls();
//
//           for (var i = 0; i < boxes.length; i++) {
//               // boxes[i].rotation.y += 0.005;
// 			  boxes[i].rotation.y += 0.002;
//   			boxes[i].rotation.x += 0.002;
// 			  boxes[i].position.y += 0.002;
// 			  // if(boxes[i].position.y>=1000){
// 				//   boxes[i].position.y = -100;
// 			  // }
//
//           }
//           renderer.render(scene, camera);
//         }

		</script>
	</body>
</html>
